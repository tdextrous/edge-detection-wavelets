% Main function.
img_file_name = 'samples/inputs/tiny_babushka.jpg';

loaded_image = imread(img_file_name);
image = im2gray(loaded_image);  % Make sure that the loaded image is grayscale

scale=2^4;  % Wavelet Transform scaling parameter.
threshold=0.15;
edges=my_wtmm(image,scale,threshold);
imshow(edges); % Show image. You will need to save it from matlab menu.

% NOTE: Increasing sigma and increasing the scale factor result in the same
% effect. You really only need to vary one of these.
function maxima=my_wtmm(I,scale,threshold)
    % Get smoothing function
    sigma=1;  % Variance value for 2-D Gaussian.
    syms X Y;
    F = exp(-((X^2+Y^2)/(2*sigma^2)));  % 2-D standard Gaussian
    
    % Get partials of our smoothing function
    % (These will be our wavelets)
    gradF = gradient(F);
    dF_x = gradF(1);
    dF_y = gradF(2);
    
    % Take the wavelet transforms with the function (image)
    % Since the cwt is equivalent to the convolution of the
    % function and the wavelet, we use a built-in method to 
    % convolve the image with a kernel generated by our wavelets.
    
    % Generate convolution kernels
    w1_kernel=generate_conv_kernel(X,Y,dF_x,scale);
    w2_kernel=generate_conv_kernel(X,Y,dF_y,scale);
    
    % Convolve the image with the wavelet kernels
    W1_f=conv2(I,w1_kernel,'same');
    W2_f=conv2(I,w2_kernel,'same');
    
    % NOTE: You can now plot these convolutions to get transformed images
    
    % Calculate modulus from wavelet transforms
    M_f=calculate_modulus(W1_f,W2_f);
    
    % Calculate angle from wavelet transforms
    A_f=calculate_angle(W1_f,W2_f);
    
    % Get modulus maxima along the angle vector
    local_maxima=calculate_modulus_maxima(M_f,A_f);
    
    % Filter the 
    maxima=threshold_values(local_maxima, threshold);
end

% Generate convolution kernels from wavelets (smoothing func partials)
% See: https://www.mathworks.com/matlabcentral/fileexchange/46189-generating-gaussian-filter-2d-matrix
function k=generate_conv_kernel(x_sym, y_sym, wavelet, scale)
    size=5;  % should be odd
    % NOTE: Other 'size' values work okay, but I think 5 works significantly better than others.
    k=zeros(size);
    
    for i=-(size-1)/2:(size-1)/2
        for j=-(size-1)/2:(size-1)/2
            x0=(size+1)/2;  % center
            y0=(size+1)/2;  % center
            x=i+x0;
            y=j+y0;
            k(y,x)=(1/scale)^2*subs(wavelet, [x_sym,y_sym], [(x-x0)/scale, (y-y0)/scale]);
        end
    end
end

% Calculate the wavelet transform modulus given two wavelet transform
% matrices
function modulus=calculate_modulus(w1,w2)
    % NOTE: We assume w1 and w2 have the same dimension
    sz1=size(w1, 1);
    sz2=size(w1, 2);
    modulus=zeros(sz1,sz2);
    
    for i=1:sz2
        for j=1:sz1
            modulus(j,i)=sqrt( (w1(j,i)^2) + (w2(j,i)^2) );
        end
    end
end

% Calculate the wavelet transform angle (radians) given two wavelet
% transform matrices
function angle=calculate_angle(w1,w2)
    % NOTE: We assume w1 and w2 have the same dimension
    sz1=size(w1, 1);
    sz2=size(w1, 2);
    angle=zeros(sz1,sz2);
    
    for i=1:sz2
        for j=1:sz1
            angle(j,i)=atan(w2(j,i)/w1(j,i));
        end
    end
end

% Basically return a filtered modulus matrix where only
% the entries that are a maximum (wrt neighbors along angle vector) are
% left
function modulus_maxima=calculate_modulus_maxima(modulus,angle)
    % NOTE: We assume modulus and angle have the same dimension
    sz1=size(modulus, 1);
    sz2=size(modulus, 2);
    modulus_maxima=zeros(sz1,sz2);
    for i=1:sz2
        for j=1:sz1
            curr_mod=modulus(j,i);
            curr_angle=angle(j,i);
            
            % init neighbor indeces
            l_neighbor_index=[0 0];
            r_neighbor_index=[0 0];
            % Determine modulus neighbors indeces along angle
            if (0 <= curr_angle) && (curr_angle < (pi/8)) ||...
               ((7*pi/8) <= curr_angle) && (curr_angle < (9*pi/8)) ||...
               ((15*pi/8) <= curr_angle) && (curr_angle < (2*pi))
                l_neighbor_index=[j i-1];
                r_neighbor_index=[j i+1];
                
            elseif ((pi/8) <= curr_angle) && (curr_angle < (3*pi/8)) ||...
                   ((9*pi/8) <= curr_angle) && (curr_angle < (11*pi/8))
               l_neighbor_index=[j+1 i-1];
               r_neighbor_index=[j-1 i+1];
               
            elseif ((3*pi/8) <= curr_angle) && (curr_angle < (5*pi/8)) ||...
                   ((11*pi/8) <= curr_angle) && (curr_angle < (13*pi/8))
               l_neighbor_index=[j+1 i];
               r_neighbor_index=[j-1 i];
               
            elseif ((5*pi/8) <= curr_angle) && (curr_angle < (7*pi/8)) ||...
                   ((13*pi/8) <= curr_angle) && (curr_angle < (15*pi/8))
               l_neighbor_index=[j-1 i-1];
               r_neighbor_index=[j+1 i+1];
            end
            
            % If indices are nondegenerate, compare against curr_mod
            is_maxima=true;
            
            % Check left neighbor
            if (l_neighbor_index(1) ~= 0 && l_neighbor_index(1) ~= sz1+1) &&...
               (l_neighbor_index(2) ~= 0 && l_neighbor_index(2) ~= sz2+1)
                l_neighbor=modulus(l_neighbor_index(1),l_neighbor_index(2));
                if l_neighbor > curr_mod
                    is_maxima=false;
                end
            end
            
            % Check right neighbor
            if (r_neighbor_index(1) ~= 0 && r_neighbor_index(1) ~= sz1+1) &&...
               (r_neighbor_index(2) ~= 0 && r_neighbor_index(2) ~= sz2+1)
                r_neighbor=modulus(r_neighbor_index(1),r_neighbor_index(2));
                if r_neighbor > curr_mod
                    is_maxima=false;
                end
            end
            
            % Add value if good.
            if is_maxima
                modulus_maxima(j,i)=curr_mod;
            end
        end
    end
end

function filtered_mat=threshold_values(mat,threshold)
    sz1=size(mat,1);
    sz2=size(mat,2);
    filtered_mat=zeros(sz1,sz2);
    for i=1:sz2
        for j=1:sz1
            if mat(j,i) > threshold
                filtered_mat(j,i)=1; %mat(j,i);
            end
        end
    end
end
